<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physically-Based Iridescent Logo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050507;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <!-- Vertex Shader -->
    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fs" type="x-shader/x-fragment">
        precision highp float;
        uniform float u_time;
        uniform vec2 u_resolution;

        // Physically grounded spectral function
        vec3 spectral(float t, vec3 tint) {
            vec3 color;
            color.r = 0.5 + 0.5 * cos(6.28318 * (t + 0.00));
            color.g = 0.5 + 0.5 * cos(6.28318 * (t + 0.15));
            color.b = 0.5 + 0.5 * cos(6.28318 * (t + 0.33));

            return mix(tint, color, 0.4);
        }

        float hash(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                       mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
        }

        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            for (int i = 0; i < 4; i++) {
                v += a * noise(p);
                p *= 2.0;
                a *= 0.5;
            }
            return v;
        }

        // TRUE SQUIRCLE SDF (Superellipse)
        // Formula: |x|^n + |y|^n = r^n
        // n=4 is often used for the classic "iOS" squircle look
        float sdSquircle(vec2 p, float r) {
            p = abs(p);
            return pow(pow(p.x, 4.0) + pow(p.y, 4.0), 1.0/4.0) - r;
        }

        vec3 renderSquircle(vec2 p, vec3 baseColor, float t) {
            float radius = 0.18;
            float d = sdSquircle(p, radius);

            // Antialiased mask
            float mask = smoothstep(0.008, 0.0, d);
            if (mask <= 0.0) return vec3(0.0);

            // Distance ratio for internal lighting (0 at center, 1 at edge)
            float distRatio = clamp(1.0 + d / radius, 0.0, 1.0);
            float angle = atan(p.y, p.x);

            // Organic thickness map
            vec2 noiseUV = p * 3.5;
            float swirl = fbm(noiseUV + t * 0.15);
            float patchiness = fbm(noiseUV * 2.0 - swirl + t * 0.1);

            float interference = pow(distRatio, 2.5) * 1.8 + patchiness * 0.6 + swirl * 0.3;
            vec3 iridescence = spectral(interference - t * 0.15, baseColor);

            // Volumetric core
            vec3 finalBase = mix(baseColor * 0.05, iridescence, pow(distRatio, 2.2));

            // Fresnel edge highlight
            float fresnel = pow(distRatio, 12.0);
            vec3 rimColor = spectral(interference + 0.3, baseColor) * fresnel * 2.5;

            // Specular Reflection
            float highlightDistort = patchiness * 0.01;
            float mainArc = smoothstep(0.035, 0.0, abs(distRatio - 0.85 + highlightDistort))
                          * smoothstep(0.65, 0.0, abs(angle - 2.35));

            vec3 color = (finalBase + rimColor);
            color += mainArc * mix(vec3(1.0), iridescence, 0.5);

            return color * mask;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / min(u_resolution.x, u_resolution.y);
            uv *= 1.5; // Zoom

            // Layout centering
            uv.y += 0.65;
            uv.x += 0.95;

            float t = u_time * 0.6;
            vec3 finalColor = vec3(0.0);

            // Logo Palette
            vec3 cBlue = vec3(0.239, 0.345, 0.725);
            vec3 cMidBlue = vec3(0.086, 0.408, 0.878);
            vec3 cCyan = vec3(0.333, 0.757, 0.929);
            vec3 cTeal = vec3(0.220, 0.878, 0.847);
            vec3 cGreen = vec3(0.153, 0.910, 0.576);

            float stepSize = 0.48;

            // Row/Column construction based on the original logo paths
            // Col 1
            finalColor += renderSquircle(uv - vec2(0.0, 0.0 * stepSize), cBlue, t);
            finalColor += renderSquircle(uv - vec2(0.0, -1.0 * stepSize), cBlue, t);
            finalColor += renderSquircle(uv - vec2(0.0, -2.0 * stepSize), cBlue, t);
            finalColor += renderSquircle(uv - vec2(0.0, -3.0 * stepSize), cBlue, t);

            // Col 2
            finalColor += renderSquircle(uv - vec2(1.0 * stepSize, -1.0 * stepSize), cMidBlue, t);
            finalColor += renderSquircle(uv - vec2(1.0 * stepSize, -2.0 * stepSize), cMidBlue, t);
            finalColor += renderSquircle(uv - vec2(1.0 * stepSize, -3.0 * stepSize), cMidBlue, t);

            // Col 3
            finalColor += renderSquircle(uv - vec2(2.0 * stepSize, -2.0 * stepSize), cCyan, t);
            finalColor += renderSquircle(uv - vec2(2.0 * stepSize, -3.0 * stepSize), cCyan, t);

            // Col 4
            finalColor += renderSquircle(uv - vec2(3.0 * stepSize, -1.0 * stepSize), cTeal, t);
            finalColor += renderSquircle(uv - vec2(3.0 * stepSize, -2.0 * stepSize), cTeal, t);
            finalColor += renderSquircle(uv - vec2(3.0 * stepSize, -3.0 * stepSize), cTeal, t);

            // Col 5
            finalColor += renderSquircle(uv - vec2(4.0 * stepSize, 0.0 * stepSize), cGreen, t);
            finalColor += renderSquircle(uv - vec2(4.0 * stepSize, -1.0 * stepSize), cGreen, t);
            finalColor += renderSquircle(uv - vec2(4.0 * stepSize, -2.0 * stepSize), cGreen, t);
            finalColor += renderSquircle(uv - vec2(4.0 * stepSize, -3.0 * stepSize), cGreen, t);

            // Fine Grain Dither
            finalColor += (hash(uv + u_time) - 0.5) * 0.008;

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            document.body.innerHTML = 'WebGL not supported';
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vsSource = document.getElementById('vs').text;
        const fsSource = document.getElementById('fs').text;
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');

        function resize() {
            canvas.width = window.innerWidth - 1000;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resize);
        resize();

        function render(time) {
            gl.uniform1f(timeLocation, time * 0.001);
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>